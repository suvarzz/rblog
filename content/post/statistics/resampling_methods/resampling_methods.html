---
title: "Resampling methods"
author: "Mark Goldberg"
date: '2019-08-03'
draft: true
math: true
tags: ["R", "Statistics", "Resampling", "Cross-validation", "Bootstrap"]
categories: ["Statistics"]
#bibliography: [bib.bib]
output:
  blogdown::html_page:
    toc: true
summary: "From the following examples we will learn wow to estimate model precision by cross-validation, validation sample and leave-one-out cross-validation (LOOCV)."
---


<div id="TOC">
<ul>
<li><a href="#validation-approach">Validation approach</a><ul>
<li><a href="#leave-one-out-cross-validation-loocv">Leave-one-out cross-validation (LOOCV)</a></li>
</ul></li>
<li><a href="#k-fold-cross-validation">k-fold cross validation</a></li>
<li><a href="#bootstrapping">Bootstrapping</a><ul>
<li><a href="#bibiography">Bibiography</a></li>
</ul></li>
</ul>
</div>

<div id="validation-approach" class="section level2">
<h2>Validation approach</h2>
<p><strong>Validation</strong> (hold-out) approach estimates the prediction error of our predictive models. This involves randomly dividing the available set of observations into two parts, a <strong>training set</strong> and a <strong>testing set</strong> (validation set). Our statistical model is fit on the training set, and the fitted model is used to predict the responses for the observations in the validation set. The resulting validation set error rate (typically assessed using <strong>MSE</strong> in the case of a quantitative response) provides an estimate of the test error rate.<br />
The drawback of the method is that the <strong>test error rate</strong> can vary depending on training set.</p>
<p>Let’s buld <strong>polinomial models</strong> for first 10 degrees to predict <strong>mpg</strong> from <strong>horsepower</strong> dataset (<code>ISLR::Auto</code>), where <strong>mpg</strong> - miles per gallon and <strong>horsepower</strong> - engine horsepower.<br />
Let’s buld models for train data using <strong>polynomial linear regression</strong> using vaious polinomial degrees and estimate MSE for each of these models using test data:<br />
1. <strong>Linear</strong>: <span class="math inline">\(\hat{mpg} = \hat{\beta}_0 + \hat{\beta}_1 \cdot horsepower\)</span>.<br />
2. <strong>Squared</strong>: <span class="math inline">\(\hat{mpg} = \hat{\beta}_0 + \hat{\beta}_1 \cdot horsepower + \hat{\beta}_2 \cdot horsepower^2\)</span>.<br />
3. <strong>Cubic</strong>: <span class="math inline">\(\hat{mpg} = \hat{\beta}_0 + \hat{\beta}_1 \cdot horsepower + \hat{\beta}_2 \cdot horsepower^2 + \hat{\beta}_3 \cdot horsepower^3\)</span>.</p>
<pre class="r"><code>library(&#39;ISLR&#39;)        # datasets Auto
attach(Auto)</code></pre>
<pre class="r"><code>set.seed(1)
# split data into train (0.6) and test (0.4)
inTrain &lt;- sample(nrow(Auto), nrow(Auto)*0.6)
train &lt;- Auto[inTrain, ]
test &lt;- Auto[!inTrain, ]

# Buld polynomial models for first ten degrees
models &lt;- lapply(1:10, function(n) {
  fit.lm &lt;- lm(mpg ~ poly(horsepower, n), data=train)
  })

mse.vec &lt;- sapply(1:10, function(n) {
  mean((mpg[-inTrain] - predict(models[[n]], Auto[-inTrain, ]))^2)
})
# create dataframe to store MSE of our models
mse.df &lt;- data.frame(degree = 1:10, mse = NA)
mse.df$mse &lt;- mse.vec
plot(mse.df, type=&quot;o&quot;, main=&quot;MSE of spline regression models for degrees from 1 to 10&quot;)</code></pre>
<p><img src="/post/statistics/resampling_methods/resampling_methods_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<pre class="r"><code>### PLOT with data and first three polynomial models
par(mar = c(4, 4, 0.5, 1))
plot(horsepower[inTrain], mpg[inTrain],
     xlab = &#39;horsepower&#39;, ylab = &#39;mpg&#39;, pch = 21,
     col = rgb(0, 0, 1, alpha = 0.4), bg = rgb(0, 0, 1, alpha = 0.4))
# add test data
points(horsepower[-inTrain], mpg[-inTrain],
       pch = 21, col = rgb(1, 0, 0, alpha = 0.4), bg = rgb(1, 0, 0, alpha = 0.4))

colors=c(&#39;black&#39;, &#39;blue&#39;, &#39;red&#39;)
x1 &lt;- data.frame(horsepower=seq(min(horsepower), max(horsepower), length = 200))
for (i in 1:3) {
    y2 &lt;- predict(models[[i]], newdata=x1)
    lines(x1$horsepower, y2, col=colors[i], lwd=c(2,2,2))
}
legend(&#39;topright&#39;, lty=c(1,1,1),
       col = c(&#39;black&#39;, &#39;blue&#39;, &#39;red&#39;, rgb(0, 0, 1, alpha = 0.4), bg = rgb(1, 0, 0, alpha = 0.4)),
       legend = c(&#39;Linear model&#39;, &#39;Squared model&#39;, &#39;Cubic model&#39;, &#39;train data&#39;, &#39;test data&#39;),
       lwd=c(2,2,2,NA,NA), pch=c(NA,NA,NA,16,16))</code></pre>
<p><img src="/post/statistics/resampling_methods/resampling_methods_files/figure-html/unnamed-chunk-2-2.png" width="672" /></p>
<pre class="r"><code># end PLOT</code></pre>
<div id="leave-one-out-cross-validation-loocv" class="section level3">
<h3>Leave-one-out cross-validation (LOOCV)</h3>
<pre class="r"><code>library(&#39;GGally&#39;)      # matrix diagrams
library(&#39;boot&#39;)        # cross-validation</code></pre>
<pre class="r"><code># fit model for train data
fit.glm &lt;- glm(mpg ~ horsepower, data = Auto)
# LOOCV-error
cv.err &lt;- cv.glm(Auto, fit.glm)
cv.err$delta[1]</code></pre>
<pre><code>## [1] 24.23151</code></pre>
<p>Estimate the precision of polynomial models by changing power.</p>
<pre class="r"><code># vector of LOOCV-errors
cv.err.loocv &lt;- rep(0, 5)
names(cv.err.loocv) &lt;- 1:5
# repeat by powers of polynomes
for (i in 1:5){
  fit.glm &lt;- glm(mpg ~ poly(horsepower, i), data = Auto)
  cv.err.loocv[i] &lt;- cv.glm(Auto, fit.glm)$delta[1]
}
# result
cv.err.loocv</code></pre>
<pre><code>##        1        2        3        4        5 
## 24.23151 19.24821 19.33498 19.42443 19.03321</code></pre>
</div>
</div>
<div id="k-fold-cross-validation" class="section level2">
<h2>k-fold cross validation</h2>
<p>K-times cross-validation is a compromize between sample validation and LOOCV. It is computationally more effective than LOOCV but not so presize.<br />
We will make 10-time validation.</p>
<pre class="r"><code>cv.err.k.fold &lt;- rep(0, 5)
names(cv.err.k.fold) &lt;- 1:5
# repeat for power of polynomes
for (i in 1:5){
  fit.glm &lt;- glm(mpg ~ poly(horsepower, i), data = Auto)
  cv.err.k.fold[i] &lt;- cv.glm(Auto, fit.glm,
                             K = 10)$delta[1]
}
# result
cv.err.k.fold</code></pre>
<pre><code>##        1        2        3        4        5 
## 24.45600 19.29844 19.38499 19.44170 19.29083</code></pre>
<p>Compare with previous result:</p>
<pre class="r"><code>mse.df</code></pre>
<pre><code>##    degree      mse
## 1       1 27.00389
## 2       2 20.21120
## 3       3 20.16025
## 4       4 20.24898
## 5       5 19.72873
## 6       6 19.57046
## 7       7 19.40368
## 8       8 20.02701
## 9       9 21.24304
## 10     10 21.11673</code></pre>
<p>Results show that error of liniear model is higher that was shown by MSE and errors are lower for polynomial regression models n=2,3.</p>
</div>
<div id="bootstrapping" class="section level2">
<h2>Bootstrapping</h2>
<p>One of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. Performing a bootstrap analysis in R entails only two steps. First, we must create a function that computes the statistic of interest. Second, we use the <code>boot()</code> function, which is part of the boot library, to perform the bootstrap by repeatedly sampling observations from the data set with replacement.<br />
Lets apply bootstrap for calculation of residual errors.</p>
<pre class="r"><code>boot.fn &lt;- function(data, index){
  coef(lm(mpg ~ horsepower, data = data, subset = index))
}
boot.fn(Auto, 1:n)

set.seed(1)
boot.fn(Auto, sample(n, n, replace = T))
# aply boot to calculate standard errors for 1000 samplings with repeats)
boot(Auto, boot.fn, 1000)
# compere with &#39;МНК&#39;
#summary(lm(mpg ~ horsepower))$coef
# оценки отличаются из-за того, что МНК -- параметрический метод с допущениями
# вычислим оценки параметров квадратичной модели регрессии
boot.fn.2 &lt;- function(data, index){
  coef(lm(mpg ~ poly(horsepower, 2), data = data, subset = index))
}
# apply bootstap with 1000 samplings
set.seed(1)
boot(Auto, boot.fn, 1000)</code></pre>
<p>Regression models errors calculated by MHK are similar byb errors calculated using bootstap</p>
<div id="bibiography" class="section level3">
<h3>Bibiography</h3>
<p><a href="http://faculty.marshall.usc.edu/gareth-james/">An Introduction to Statistical Learning by Gareth James</a><br />
<a href="https://afit-r.github.io">Air Forse Institute of Technology</a></p>
</div>
</div>
